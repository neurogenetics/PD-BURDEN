#!/bin/env python

# Manhattan Plotter for Burden Results (adapted from Jeff's script)
    # Start script like this:
    # Takes in .assoc files generated by RVTests
        # python new-manhattans.py \
        # --input gne.ALL_LOF_HC_LOFTEE.freqUpper0.01.SkatO.assoc \
        # --cohort GENENTECH \
        # --variant_group ALL_LOF_HC_LOFTEE \
        # --maf 0.01 \
        # --test SkatO \
        # --numvar 0 \
        # --meta none \
        # --output gne.ALL_LOF_HC_LOFTEE.freqUpper0.01.SkatO

# Import the necessary packages
import numpy as np
import pandas as pd
import math
import sys
import os
from functools import reduce
import argparse
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patheffects as PathEffects
from adjustText import adjust_text

# Initialize parser and add arguments
parser = argparse.ArgumentParser()
parser.add_argument("--input", "-i", help="Input file name (with suffix) for .assoc or .tab")

parser.add_argument("--cohort", help="Input string with what groups are being analyzed")
parser.add_argument("--variant_group", help="Input string with what variant group was looked at")
parser.add_argument("--maf", help="Input string with what MAF was looked at")
parser.add_argument("--meta", help="Meta-analysis Approach")
parser.add_argument("--test", choices=["SkatO", "CMCWald"], help="What test was run? Options are SkatO or CMC")
parser.add_argument("--numvar", metavar='N', type=int, default=0, help="Keep genes with variants equal to or greater than this number")
parser.add_argument("--output", "-o", help="Desired output name for files (without suffix)")
args = parser.parse_args()

## Defining functions - modified from Jeff K
def manhattanPlot(input_dat, columnNames="auto", title="", negLogP=False, output=False, dpi=500, aspect_ratio=2, sig=5e-8, highlight=True, sigLine=True, sigLineColor='r', plotColors=None, dotSize=6, annotate=False, textSize='small', arrowColor='gray'):
    """
    Generate Manhattan Plot or Miami Plot (Two Manhattan Plot mirrored to each other)
        Arguments:
            input_dat : pd.DataFrame or list
                DataFrame containing Chromosome, Basepair position, and P value.
                If a list, assume Miami Plot. Must be a list of two pd.DataFrame objects.
            columnNames : str or list, default "auto"
                Names of the columns. Must be provided in order of: CHR, BP, P.
                When set to "auto", attempts to automatically detect column names.
            title : str, default ""
                Plot title
            negLogP : bool, default False
                Set to True if provided P value column is -logP
            output : bool or str, default False
                Path and name of desired plot.
            dpi : int, default 500
                DPI of the output PNG plot. Only relevant if output is specified.
            aspect_ratio : float, default 2
                Aspect ratio of the plot. Length/height. Default value is set to 2:1
                length:height ratio.
            sig : float, default 5e-8
                Significance level. This determines significance line and highlight.
            highlight : bool or pd.Series, default True
                When True (default), highlights all significant SNPs. Significance determined
                by argument "sig"
            sigLine : bool, default True
                Horizontal line delineating significance.
            sigLineColor : str, default "r"
                Set sigLine color
            plotColors : list, default None
                Set colors for chromosomes and highlights. Colors will be automatically
                assigned when set to None. Minimum 2 colors for no highlight. 3 colors for
                manhattan with highlight, 4 for miami with highlight.
            dotSize : float, default 6
                Between 1 and 20. Set dot size for the scatterplot.
            annotate : pd.DataFrame, list, or bool, default False
                Path of SNPs to annotate. Columns must be: CHR, BP, TEXT. If input_dat is a
                list, provide list of two pd.DataFrame in the same order as the input_dat
            textSize : str, default 'small'
                Size of the annotation text
            arrowSize : str, default 'green'
                Color of the annotation arrow
            
    """
## if you want annotations, you add that separately
# CHR BP TEXT data frame
# on annotate argument

    # detect miami plot
    if isinstance(input_dat, list):
        miami = True
        print("List detected, assuming Miami Plot.")
        if set(list(input_dat[0])) == set(list(input_dat[1])):
            print("Column names are the same")
        else:
            raise ValueError("Column names inconsistent. Please make sure column names are identical for both DataFrames")
    else:
        miami = False
    
    # autodetect columns    
    if isinstance(columnNames, list):
        columnNames == columnNames
        print("Columns to read: ", columnNames)
    elif columnNames == "auto":
        if miami:
            dat_columns = list(input_dat[0].columns)
        else:
            dat_columns = list(input_dat.columns)
        chr_col=[]
        detected_col=[chr_col,chr_col,chr_col]
        chr_strings = ['Chromosome','CHROMOSOME','chromosome','chrom','Chrom','CHROM','chr','CHR','Chr','scaffold','SCAFFOLD','Scaffold']
        bp_strings = ['Position','position','POSITION','bp','Bp','BP','Pos','POS','pos']
        p_strings = ['P-value_association','P.value_association','P-VALUE','P-value','p-value','Pval','PVAL','pval','p','P', 'Pvalue']
        autodetect_strings = [chr_strings,bp_strings,p_strings]
        string_names = ["Chromosome","Position","P value"]
        for a in range(0,3):
            i=0
            while len(detected_col[a]) == 0 & i != len(autodetect_strings[a]):
                detected_col[a] = [col for col in dat_columns if autodetect_strings[a][i] == col]
                i = i+1
            i=0
            while len(detected_col[a]) == 0 & i != len(autodetect_strings[a]):
                detected_col[a] = [col for col in dat_columns if autodetect_strings[a][i] in col]
                i = i+1
            if len(detected_col[a]) == 0:
                error_message = "".join(["Unable to detect ", string_names[a], " column. Please provide chromosome column using argument columnNames."])
                raise ValueError(error_message)
            if len(detected_col[a]) == 1:
                detected_col[a]=detected_col[a][0]
            else:
                error_message = "".join(["Multiple column names for ", string_names[a]," detected. Please narrow down input data columns. Columns detected: ", "".join(detected_col[a])])
                raise ValueError(error_message)
        columnNames = detected_col
        print("Detected columns:", detected_col)
    else:
        error_message = "".join(["columnNames argument is not \"auto\" or a list. Please set to \"auto\" or provide a list of column names in order of Chromosome, Position, P-value. columnNames provided:", ",".join(columnNames)])
        raise ValueError(error_message)
    logsig = -np.log10(sig)
    
    # miami: rename columns, calculate -logP, highlight, concat data to single df
    if miami:
        input_dat[0] = input_dat[0].rename(columns={columnNames[0]:"CHR", columnNames[1]:"BP", columnNames[2]:"P"})
        input_dat[1] = input_dat[1].rename(columns={columnNames[0]:"CHR", columnNames[1]:"BP", columnNames[2]:"P"})
        input_dat[0] = input_dat[0][["CHR", "BP", "P"]]
        input_dat[1] = input_dat[1][["CHR", "BP", "P"]]
        if negLogP:
            input_dat[0] = input_dat[0].rename(columns={'P':"neglogP"})
            input_dat[1] = input_dat[1].rename(columns={'P':"neglogP"})
            input_dat[1]["neglogP"] = -input_dat[1]["neglogP"]
        else:
            input_dat[0]['neglogP'] = -input_dat[0]["P"].apply(np.log10)
            input_dat[1]['neglogP'] = input_dat[1]["P"].apply(np.log10)
        input_dat[0]["CHR_color"] = float("NaN")
        input_dat[1]["CHR_color"] = float("NaN")
        # if highlight is true, highlight significant variants
        # if highlight is a list of series, highlight the corresponding variants
        if isinstance(highlight, list):
            input_dat[0].loc[highlight[0], "CHR_color"] = 3
            input_dat[1].loc[highlight[1], "CHR_color"] = 4
        elif isinstance(highlight, pd.Series):
            raise ValueError("Provided a single series for highlighting Miami plot. Please disable Miami plot or provide a list with two series for highlights.")
        elif highlight==True:
            input_dat[0].loc[input_dat[0]['neglogP'] > logsig, "CHR_color"] = 3
            input_dat[1].loc[input_dat[1]['neglogP'] < -logsig, "CHR_color"] = 4
        dat = pd.concat([input_dat[0], input_dat[1]]).drop(columns=["P"])
    # manhattan: rename columns, calculate -logP, highlight
    else:
        input_dat = input_dat.rename(columns={columnNames[0]:"CHR", columnNames[1]:"BP", columnNames[2]:"P"})
        input_dat = input_dat[["CHR", "BP", "P"]]
        if negLogP:
            input_dat = input_dat.rename(columns={'P':"neglogP"})
        else:
            input_dat['neglogP'] = -np.log10(input_dat["P"])
        input_dat["CHR_color"] = float("NaN")
        # if highlight is true, highlight significant variants
        # if highlight is a series, highlight the corresponding variants
        if isinstance(highlight, pd.Series):
            input_dat.loc[highlight, "CHR_color"] = 2
        elif highlight==True:
            input_dat.loc[input_dat['neglogP'] > logsig, "CHR_color"] = 2
        dat = input_dat.drop(columns=["P"])
    
    # assign chromosome colors
    #OddChrMask = (dat.CHR_color.isnull()) & (dat.CHR%2 == 1)
    #EvenChrMask = (dat.CHR_color.isnull()) & (dat.CHR%2 == 0)
    
    OddChrMask = (dat['CHR_color'].isnull()) & (dat['CHR']%2 == 1)
    EvenChrMask = (dat['CHR_color'].isnull()) & (dat['CHR']%2 == 0)
    dat.loc[OddChrMask, 'CHR_color'] = 0
    dat.loc[EvenChrMask, 'CHR_color'] = 1
    dat = dat.sort_values(['CHR','BP'])
    # indexing for position in scatterplot
    # also annotation detection + annotation data generation
    chr_range = range(2,23)
    if miami:
        chr1_bp_max = np.amax(dat.loc[(dat["CHR"]==1),'BP'])
        bp_max=np.array([chr1_bp_max,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
        for i in chr_range:
            bp_max[i-1] = np.amax(dat.loc[(dat["CHR"]==i),'BP']) + bp_max[i-2]
        dat["bpcum"] = dat["BP"]
        for chromosome in chr_range:
            n = chromosome-1
            dat_filter = (dat['CHR'] == chromosome)
            dat.loc[dat_filter, "bpcum"] = dat[dat_filter].BP + bp_max[chromosome-2] + 3e7*n
        if isinstance(annotate, list):
            print("Annotation detected. Correct type (list)")
            annotation_top = dat[dat['neglogP'] > 0].merge(annotate[0], on=['CHR','BP'])
            annotation_bottom = dat[dat['neglogP'] < 0].merge(annotate[1], on=['CHR','BP'])
            if annotation_top.shape[0] != annotate[0].shape[0]:
                print('Some data in first annotation df lost, please make sure all rows are legal')
            if annotation_bottom.shape[0] != annotate[1].shape[0]:
                print('Some data in second annotation df lost, please make sure all rows are legal')
            annotation = pd.concat([annotation_top, annotation_bottom], ignore_index=True)
            annotation = annotation.rename(columns={'bpcum':'i'})
    else:
        dat.reset_index(inplace=True, drop=True)
        dat['i'] = dat.index
        for i, chromosome in enumerate(pd.unique(dat['CHR'])):
            if i != 0:
                inChromosome = (dat['CHR'] == chromosome)
                dat.loc[inChromosome, 'i'] = dat.loc[inChromosome].i + 3e-7*i
        if isinstance(annotate, pd.DataFrame):
            print("Annotation detected. Correct type (pd.DataFrame)")
            annotation = dat.merge(annotate, how="right", on=['CHR','BP'])
    # print(dat.CHR_color.unique()) #debug script
    # set plot colors
    if plotColors==None:
        print("Using default color scheme")
        colorNum = len(dat.CHR_color.unique())
        if (colorNum == 4):
            print("Detecting 4 colors")
            plotColors = ["#A6CEE3", "#1F78B4", "#D81B60", "#FF7F00"] # Blues and orange
            #plotColors = ["#d1d5de", "#b7b6c2", "DB2B39", "#443742"] # Lavender and mauve
        elif (colorNum == 3):
            print("Detecting 3 colors")
            plotColors = ["#A6CEE3", "#1F78B4", "#FF7F00"] # Blues and orange 
            #plotColors = ["#d1d5de", "#b7b6c2", "#443742"] # Lavender and mauve
        elif (colorNum == 2):
            print("Detecting 2 colors")
            plotColors = ["#A6CEE3", "#1F78B4"] # Blues
        
    # plot
    print("Generating plot")
    if miami:
        plot = sns.relplot(data=dat, x='bpcum', y='neglogP', aspect=aspect_ratio, hue='CHR_color', palette = plotColors, legend=None, edgecolor="none", s=dotSize) 
        Chromosome_dat = dat.groupby('CHR')['bpcum'].median()
        plot.ax.set_xlabel('Chromosome')
        plot.ax.set_ylabel('-logP')
        plot.ax.set_xticks(Chromosome_dat)
        plot.ax.set_xticklabels(Chromosome_dat.index)
        #plot.fig.suptitle(title);
        plt.title(title)
        plot.ax.set_alpha(0.0)
        if sigLine:
            plt.plot([np.amin(dat["bpcum"]), np.amax(dat["bpcum"])], [logsig,logsig], "--", color=sigLineColor)
            plt.plot([np.amin(dat["bpcum"]), np.amax(dat["bpcum"])], [-logsig,-logsig], "--", color=sigLineColor)
    else:
        plot = sns.relplot(data=dat, x='i', y='neglogP', aspect=aspect_ratio, 
                   hue="CHR_color", palette = plotColors, legend=None, edgecolor="none", s=dotSize) 
        Chromosome_dat_manhattan = dat.groupby('CHR')['i'].median()
        plot.ax.set_xlabel('Chromosome')
        plot.ax.set_ylabel('-logP')
        plot.ax.set_xticks(Chromosome_dat_manhattan)
        plot.ax.set_xticklabels(Chromosome_dat_manhattan.index)
        #plot.fig.suptitle(title)
        plt.title(title)
        if sigLine:
            plt.plot([0, dat.shape[0]], [logsig,logsig], "--", color=sigLineColor)
    # set transparent background
    plot.ax.set(facecolor = [0,0,0,0])
    plot.ax.spines['bottom'].set(color = [0,0,0,0])
    plot.ax.tick_params(axis='x', colors=[0,0,0,0], length=0)
    loopiter = 0
    for i, ticklabel in enumerate(plt.gca().get_xticklabels()):
        loopiter = i%2
        ticklabel.set_color(plotColors[loopiter])
    # add annotations if annotations is not false
    print("Adding annotation text. If there are many annotation markers, overlap-adjustment may take time so please be patient.")
    #print('Size of total annotation df: ', annotation.shape[0])
    if isinstance(annotate, (pd.DataFrame, list)):
        #annotx = annotation['i']
        #annoty = annotation['neglogP']
        #annottext = annotation['TEXT']
        texts = [plt.text(
            annotation['i'][i],
            annotation['neglogP'][i],
            annotation['TEXT'][i],
            style='italic',
            size=textSize,
            # bbox=dict(facecolor='white', edgecolor='black', alpha=0.5),
            ha='center',
            va='center',
            zorder=10,
            path_effects=[PathEffects.withStroke(linewidth=1,
                                                 foreground="w")]
            ) for i in range(
            annotation.shape[0]#len(annotx)
        )]
        adjust_text(
            texts,
            avoid_points = False,
            avoid_self = False,
            expand_text=(1.2, 1.4),
            force_text=(0.2, 0.9),
            only_move={'points':'xy', 'text':'xy', 'objects':'xy'},
            arrowprops=dict(arrowstyle='-', color=arrowColor, zorder=5)
        )
    # Get the first two and last y-tick positions.
    #miny, nexty, *_, maxy = plot.ax.get_yticks()

    # Compute half the y-tick interval (for example).
    #eps = (nexty - miny) / 2  # <-- Your choice.
    #plot.ax.set_ylim(maxy+eps, miny-eps)
    if output!=False:
        plt.savefig(output, dpi=dpi, edgecolor='none', bbox_inches='tight')
    #plt.show()


## Reading in variables
input_file = args.input

cohort = args.cohort
variants = args.variant_group
maf = args.maf
test = args.test
numvar = args.numvar
meta_approach = args.meta

# Read in your separate .assoc or .tab files
# For the individual cohort files, subset by numvar (this was already done for the meta files prior)

print("Reading in your dataset...")
try:
    keep_cols = ['gene', 'P', 'numvars']
    raw_df = pd.read_csv(input_file, sep="\t", usecols=keep_cols)
    raw_df.rename(columns={"gene": "Gene",
                           "P":"Pvalue",
                          "numvars":"NumVar"}, inplace=True)
    raw_df = raw_df[raw_df['NumVar']>= numvar]
except ValueError:
    try:
        keep_cols = ['Gene', 'Pvalue', "NumVar"]
        raw_df = pd.read_csv(input_file, sep="\t", usecols=keep_cols)
        raw_df = raw_df[raw_df['NumVar']>= numvar]
    except ValueError:
        keep_cols = ['GENE', 'META_PVAL']
        raw_df = pd.read_csv(input_file, sep="\t", usecols=keep_cols)
        raw_df.rename(columns={"GENE": "Gene",
                               "META_PVAL":"Pvalue"}, inplace=True)

## Read in the refFlat file
header_text = ['CHR', 'BP', 'END_BP', 'Gene']
refflat_df = pd.read_csv("/data/CARD/PD/AMP_NIH/no_relateds/meta_risk_analysis/geneburden_risk_wGenentech/RECESSIVE_SEARCH/refFlat-gene-range-noDupGenes.txt", sep=" ", header=0, names=header_text)
#refflat_df = pd.read_csv("refFlat-gene-range-noDupGenes.txt", sep=" ", header=0, names=header_text)
refflat = refflat_df[refflat_df[['CHR']].apply(lambda x: x[0].isdigit(), axis=1)].copy()
refflat['CHR'] = refflat['CHR'].astype('Int64')

## Merge the files 
pre_merged_df = pd.merge(raw_df, refflat, on="Gene", how="left")
pre_merged_df['BP'] = pre_merged_df['BP'].astype('Int64')
merged_df = pre_merged_df[['CHR', "BP", "Pvalue", "Gene"]].copy()

# Drop any NAs 
merged_df.dropna(inplace=True)

## Generate annotation file
lead_genes_1e6 = merged_df[merged_df['Pvalue'].astype('float')<0.000001]
lead_genes = lead_genes_1e6[['CHR', 'BP', 'Gene']].copy()
lead_genes.rename(columns={"Gene": "TEXT"}, inplace=True)

## Plot details 
## Make plot title 
new_line = '\n'

plot_title = f'COHORT: {cohort}; {new_line} TEST: {test}; META-APPROACH: {meta_approach}; MAF: {maf}; NUMVAR >= {numvar} {new_line} VARIANT CLASS: {variants}'

## Output details 
output_file = args.output + ".manhattan.1e-6.jpg"

## Run Manhattan
if lead_genes.empty:
    manhattanPlot(
        merged_df,
        sig = 1e-6,
        dpi = 300,
        aspect_ratio=3,
        title = plot_title,
        highlight=False,
        output = output_file)
    
else:
    manhattanPlot(
        merged_df,
        annotate = lead_genes,
        sig = 1e-6,
        dpi = 300,
        aspect_ratio=3,
        title = plot_title,
        output = output_file)

## Tell user we're done
print(f"All done! Your plot is at {output_file}")
